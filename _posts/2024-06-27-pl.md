---
layout: post
title: Force Attractions
date: 2024-06-27 23:27 -0400
permalink: pl
categories: math cs
thumbnail: img/pltn.webp
---
## Matrix Attraction Algorithm

The algorithm we'll build up to here is an implementation of [particle life](https://particle-life.com/), and the idea is amazingly simple. That's not to take away from the beauty of it, but more-so to relate it back to our notions of cellular automata. 

Whether or not this system actually is a [CA](https://www.wolframscience.com/nks/) or just a regular [automaton](https://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html) is not something I will try to parse hereâ€” but the spirit of particle life is in setting up a basic set of rules and watching the system *evolve*. 

I don't consider there to be any sort of [evolution](https://en.wikipedia.org/wiki/Evolution) happening here, since there are no 'generations' or mechanisms of propagating natural selection, but it's hard to look at the changing [emergent behaviors](https://en.wikipedia.org/wiki/Emergence) and not at least feel some flavor of biology. 

## The Big Idea

We take a few [classes](https://mathworld.wolfram.com/EquivalenceClass.html) of cells, and throw them into our world. Each class has fixed [attractive forces](https://en.wikipedia.org/wiki/Force) between other classes and including the interaction of one class acting on itself. 

With just these simple ideas you can begin to build very interesting simulations.


\
Here's an example script where using an arbitrary [attraction function](https://mathworld.wolfram.com/GaussianFunction.html). Press spacebar to change the matrix, and feel free to adjust parameters as you see fit!

It's important to note the use of [vectorized operations](https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html) here to keep computation time slow. 



```
import colorsys as cs
import numpy as np
import cv2

DISPLAY_SIZE = 512

CLASSES = 4
AGENTS = 256

FORCE_FACTOR = 0.00001
FRICTION = 0.01

# We'll define our agents
pX = np.random.uniform(0, 1, AGENTS)
pY = np.random.uniform(0, 1, AGENTS)

vX = np.zeros(AGENTS)
vY = np.zeros(AGENTS)

C = np.random.randint(0, CLASSES, AGENTS)

# We'll define a matrix of the attractions
A = np.random.uniform(-1, 1, (CLASSES, CLASSES))
A /= np.max(A)


def randomize_attractions():
    global A
    A = np.random.randn(CLASSES, CLASSES) * 2 - 1
    A /= np.max(A)


def force(R, A):
    # R is the radius between two agents
    # A is the attraction matrix
    return A * np.exp(-64 * (R - 0.25)**2)


def update():

    global pX, pY, vX, vY, C

    totalF_X = np.zeros(AGENTS, dtype=np.float32)
    totalF_Y = np.zeros(AGENTS, dtype=np.float32)

    for i in range(AGENTS):
        distX = np.abs(pX - pX[i])
        distY = np.abs(pY - pY[i])

        r = np.sqrt(distX**2 + distY**2)
        F = force(r, A[C[i], C])

        r += 1e-5

        totalF_X += F * distX / r
        totalF_Y += F * distY / r

    vX += totalF_X * FORCE_FACTOR - vX * FRICTION
    vY += totalF_Y * FORCE_FACTOR - vY * FRICTION

    maskX = np.where(np.logical_or(pX < 0, pX > 1), -1, 1)
    maskY = np.where(np.logical_or(pY < 0, pY > 1), -1, 1)

    vX *= maskX
    vY *= maskY

    pX += vX
    pY += vY


HUE = np.float16(C / CLASSES)
HUE = np.clip(HUE, 0, 1)

while True:

    update()

    img = np.zeros((512, 512, 3), dtype=np.uint8)

    for i in range(AGENTS):
        x = int(pX[i] * DISPLAY_SIZE)
        y = int(pY[i] * DISPLAY_SIZE)

        
        HSV = [HUE[i], 1, 1]
        RGB = cs.hsv_to_rgb(HSV[0], HSV[1], HSV[2])
        RGB = tuple([int(a * 255) for a in RGB])

        cv2.circle(img, (x, y), 3, RGB, -1, cv2.LINE_AA)


    cv2.imshow('Attractors', img)

    key = cv2.waitKey(1) & 0xFF
    if key == ord('q') or cv2.getWindowProperty('Attractors', cv2.WND_PROP_VISIBLE) < 1:
        break
    
    if key == 32:
        randomize_attractions()
        print('Randomizing attractions')

cv2.destroyAllWindows()
```


## Next Steps

It's easy to extend these rules and modify them. The [PL creator](https://particle-life.com/about/tom-mohr.html) considers negative force when particles are close together, giving the spongey biological nature we all know and love. 

We may also consider using [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic) to make the particles wrap around the screen.

NumPy arrays are pretty fast, so scaling [into the third dimension](https://en.wikipedia.org/wiki/Vanishing_point) is well within our computational bounds.

Overall, there is a lot of experimentation and beauty that can come about, so we should be sure to explore.


## Gallery


### Aquarium
{% include youtubePlayer.html id='4ibSUymdJV0?si=AHXfuQ90IDj3N8Pj' %}

### Pollen

{% include youtubePlayer.html id='-c4iUYWf62g?si=GwVmKvTFO7mvLEwL' %}